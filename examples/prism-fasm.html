<h2>Full example</h2>
<pre><code>
; A tiny SKI calculus evaluator.
; Copyright (C) Kamila Szewczyk, 2020.
; ------------------------------------
; A bit smarter version of the bundled 976-byte binary,
; it doesn&#39;t leak the memory like a sieve and starts a bit faster,
; at the expense of being larger out-of-the-box (I could pack it
; with my packer to around 1,66K).

format PE GUI 4.0

entry _start

include &#39;win32ax.inc&#39;

; Node in memory:

; ESI     ESI&#43;4     ESI&#43;8
; v       v         v
; &#43;--------------------------&#43;
; | left  |  right  |  type  |
; &#43;--------------------------&#43;

node.left  equ 0
node.right equ 4
node.type  equ 8

; SKI nodes
TYPE_S  equ 0
TYPE_K  equ 1
TYPE_I  equ 2

; alloc_node node holding two other nodes.
TYPE_BI equ 3

section &#39;.text&#39; code readable executable writeable
    ; Program entry point.
    ; Create the dialog, hook up the dialog procedure,
    ; enter an event loop.
    proc _start
        ; Create a heap, store it&#39;s handle in asmh.
        invoke HeapCreate, 0, 0, 0
        mov DWORD [asmh], eax
        ; Get the handle of the current module
        invoke GetModuleHandleA, 0
        ; ... and use it to create a dialog box.
        ; 1 here is the resource identifier for the form.
        invoke CreateDialogParamA, eax, 1, 0, DialogProc, 0
        ; store the dialog handle in hDlg.
        mov DWORD [hDlg], eax
        ; show the dialog.
        invoke ShowWindow, eax, SW_SHOW
        ; window message loop.
    .message_loop:
        ; fetch the next message to msg.
        invoke GetMessage, msg, 0, 0, 0
        ; GetMessage returns 0 =&gt; quit
        test eax, eax
        je .quit
        ; if the return value != -1
        inc eax
        jne .isdlg
        ; return value == -1 =&gt; an error occured.
        ; ExitProcess(1)
        push 1
        jmp .die
    .isdlg:
        ; is it a dialog message?
        invoke IsDialogMessageA, hDlg, msg
        ; nope, ignore.
        test eax, eax
        jne .message_loop
        ; Otherwise, translate and dispatch it.
        invoke TranslateMessage, msg
        invoke DispatchMessage, msg
        jmp .message_loop
    .quit:
        ; ExitProcess(0)
        push 0
    .die:
        call [ExitProcess]
    endp

    ; Dialog procedure - handling incoming messages.
    proc DialogProc
        ; Stack frame construction.
        push ebp
        mov ebp, esp
        sub esp, 16
        mov edx, DWORD [ebp&#43;12]
        mov eax, DWORD [ebp&#43;8]
        mov ecx, DWORD [ebp&#43;16]
        ; handle WM_CLOSE
        cmp edx, WM_CLOSE
        je .close_handler
        ; handle WM_COMMAND
        cmp edx, WM_COMMAND
        je .command_handler
        ; don&#39;t handle everything not being WM_DESTROY
        ; (return FALSE)
        cmp edx, WM_DESTROY
        jne .no_op
        ; ... so we&#39;re handling WM_DESTROY here.
        invoke PostQuitMessage, 0
        jmp .c_exit
    .close_handler:
        ; WM_CLOSE =&gt; pass around the WM_DESTROY message.
        invoke DestroyWindow, eax
    .c_exit:
        ; common WM_DESTROY and WM_CLOSE fallthrough.
        ; return TRUE.
        xor ebx, ebx
        inc ebx
        ; the only way out is to
        jmp .die
    .command_handler:
        ; 2 is the &#39;&amp;Quit&#39; button ID.
        ; If anything other has been pressed, branch.
        cmp cx, 2
        jne .not_quit
        ; Quit button pressed -&gt; die
        invoke DestroyWindow, eax
    .no_op:
        ; a RETURN FALSE stub for lacking handlers for
        ; WM_COMMAND cases and unknown message ID&#39;s.
        xor ebx, ebx
        jmp .die
    .not_quit:
        ; &#39;&amp;Quit&#39; wasn&#39;t pressed, so maybe it was &#39;&amp;Evaluate&#39;?
        ; return FALSE if LOWORD(ecx) != 1
        xor ebx, ebx
        dec cx
        jne .die
        ; &#39;&amp;Evaluate&#39; pressed, handle that.
        ; Get the handle to the 3rd dialog item =&gt; the expression input
        invoke GetDlgItem, eax, 3
        ; stuff it in wnd
        mov DWORD [wnd], eax
        ; get the text length to allocate approperiate amount of space on the stack
        invoke GetWindowTextLengthA, eax
        ; Save the esp
        mov ecx, esp
        ; Reserve space for the null terminator.
        ; Basically, we&#39;re constructing a buffer on the stack
        lea edx, [eax&#43;1]
        add eax, 17
        and eax, 0xFFFFFFF0
        sub ecx, eax
        mov esp, ecx
        ; While we&#39;re at it, null-terminate it.
        mov BYTE [esp], 0
        ; Read the control data, put it in the buffer.
        mov DWORD [ebp-12], ecx
        invoke GetWindowTextA, DWORD [wnd], ecx, edx
        mov ecx, DWORD [ebp-12]
        ; Evaluate it.
        call eval
        ; Reset the control text.
        invoke SetWindowText, DWORD [wnd], eax
    .die:
        ; Pop off the VLA
        lea esp, [ebp-8]
        ; Set the correct return value.
        mov eax, ebx
        ; Balance the stack
        pop ebx
        pop esi
        pop ebp
        ret 16
    endp
    
    ; ...

wnd:  dd 0
msg   MSG
hDlg: dd 0
asmh: dd 0
buf:  dd 0
code: dd 0
ski:  db &#39;SKI&#39;, 0
msge: db &#39;?&#39;, 0

section &#39;.rsrc&#39; resource data readable
directory RT_DIALOG, dialogs
resource dialogs, 1, LANG_ENGLISH&#43;SUBLANG_DEFAULT, demo
dialog demo,&#39;SKI calculus&#39;,70,70,330,20,WS_CAPTION&#43;WS_POPUP&#43;WS_SYSMENU&#43;DS_MODALFRAME
    dialogitem &#39;STATIC&#39;, &#39;&amp;Code: &#39;, 4, 4, 5, 21, 9, WS_VISIBLE&#43;WS_CHILD&#43;WS_GROUP
    dialogitem &#39;BUTTON&#39;, &#39;&amp;Quit&#39;, 2, 269, 4, 50, 11, BS_PUSHBUTTON&#43;WS_CHILD&#43;WS_VISIBLE&#43;WS_GROUP
    dialogitem &#39;BUTTON&#39;, &#39;&amp;Evaluate&#39;, 1, 218, 4, 50, 11, BS_DEFPUSHBUTTON&#43;WS_CHILD&#43;WS_VISIBLE&#43;WS_GROUP
    dialogitem &#39;EDIT&#39;, &#39;&#39;, 3, 28, 3, 187, 14, ES_LEFT&#43;WS_CHILD&#43;WS_VISIBLE&#43;WS_BORDER&#43;WS_GROUP&#43;ES_AUTOHSCROLL
enddialog

section &#39;.idata&#39; import data readable writable
library kernel32, &#39;KERNEL32.DLL&#39;, \
        user32, &#39;USER32.DLL&#39;

include &#39;api\kernel32.inc&#39;
include &#39;api\user32.inc&#39;
</code></pre>
