!function(e){function n(e){return RegExp("(\\()(?:"+e+")(?=[\\s\\)])")}function a(e){return RegExp("([\\s([])(?:"+e+")(?=[\\s)])")}var t={heading:{pattern:/;;;.*/,alias:["comment","title"]},comment:/;.*/,string:{pattern:/"(?:[^"\\]|\\.)*"/,greedy:!0,inside:{argument:/[-A-Z]+(?=[.,\s])/,symbol:/`(?!\d)[-+*/~!@$%^=<>{}\w]+'/}},"quoted-symbol":{pattern:/#?'(?!\d)[-+*/~!@$%^=<>{}\w]+/,alias:["variable","symbol"]},"lisp-property":{pattern:/:(?!\d)[-+*/~!@$%^=<>{}\w]+/,alias:"property"},splice:{pattern:/,@?(?!\d)[-+*/~!@$%^=<>{}\w]+/,alias:["symbol","variable"]},keyword:[{pattern:/(\()(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)(?=\s)/,lookbehind:!0},{pattern:/(\()(?:append|by|collect|concat|do|finally|for|in|return)(?=\s)/,lookbehind:!0}],declare:{pattern:n("declare"),lookbehind:!0,alias:"keyword"},interactive:{pattern:n("interactive"),lookbehind:!0,alias:"keyword"},boolean:{pattern:a("nil|t"),lookbehind:!0},number:{pattern:a("[-+]?\\d+(?:\\.\\d*)?"),lookbehind:!0},defvar:{pattern:/(\()def(?:const|custom|group|var)\s+(?!\d)[-+*/~!@$%^=<>{}\w]+/,lookbehind:!0,inside:{keyword:/^def[a-z]+/,variable:/(?!\d)[-+*/~!@$%^=<>{}\w]+/}},defun:{pattern:/(\()(?:cl-)?(?:defmacro|defun\*?)\s+(?!\d)[-+*/~!@$%^=<>{}\w]+\s+\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*\)/,lookbehind:!0,greedy:!0,inside:{keyword:/^(?:cl-)?def\S+/,arguments:null,function:{pattern:/(^\s)(?!\d)[-+*/~!@$%^=<>{}\w]+/,lookbehind:!0},punctuation:/[()]/}},lambda:{pattern:/(\()lambda\s+\(\s*(?:&?(?!\d)[-+*/~!@$%^=<>{}\w]+(?:\s+&?(?!\d)[-+*/~!@$%^=<>{}\w]+)*\s*)?\)/,lookbehind:!0,greedy:!0,inside:{keyword:/^lambda/,arguments:null,punctuation:/[()]/}},car:{pattern:/(\()(?!\d)[-+*/~!@$%^=<>{}\w]+/,lookbehind:!0},punctuation:[/(?:['`,]?\(|[)\[\]])/,{pattern:/(\s)\.(?=\s)/,lookbehind:!0}]},r={"lisp-marker":/&(?!\d)[-+*/~!@$%^=<>{}\w]+/,varform:{pattern:/\((?!\d)[-+*/~!@$%^=<>{}\w]+\s+(?=\S)(?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*\)/,inside:t},argument:{pattern:/(^|[\s(])(?!\d)[-+*/~!@$%^=<>{}\w]+/,lookbehind:!0,alias:"variable"},rest:t},s={pattern:/(\()(?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*(?=\))/,lookbehind:!0,inside:{"rest-vars":{pattern:/&(?:body|rest)\s+\S+(?:\s+\S+)*/,inside:r},"other-marker-vars":{pattern:/&(?:aux|optional)\s+\S+(?:\s+\S+)*/,inside:r},keys:{pattern:/&key\s+\S+(?:\s+\S+)*(?:\s+&allow-other-keys)?/,inside:r},argument:{pattern:/(?!\d)[-+*/~!@$%^=<>{}\w]+/,alias:"variable"},punctuation:/[()]/}};t.lambda.inside.arguments=s,t.defun.inside.arguments=e.util.clone(s),t.defun.inside.arguments.inside.sublist=s,e.languages.lisp=t,e.languages.elisp=t,e.languages.emacs=t,e.languages["emacs-lisp"]=t}(Prism);